desc:Super8 MIDI-controlled synchronized looper

// uses natural notes as base pairs for record/play: 
//   (CD FGA CD) 36, 38, 41, 43, 45, 48, 50, 53
// note base=start record/end loop. base+1 = play loop (stops record), or stop

in_pin:input 1
in_pin:input 2
in_pin:input 3
in_pin:input 4
in_pin:input 5
in_pin:input 6
in_pin:input 7
in_pin:input 8
out_pin:output 1
out_pin:output 2
out_pin:output 3
out_pin:output 4
out_pin:output 5
out_pin:output 6
out_pin:output 7
out_pin:output 8
out_pin:monitor output

@init

// constants
g_nchan = 8;
g_max_alloc = 8<<20; // JSFX memory available
g_maxlen = ((g_max_alloc-4096)/g_nchan)|0; // use nearly all of available memory
g_fadespeed = 0.99;
g_fadespeed2 = 1.0-g_fadespeed;
g_infthreshdb = -120;
g_infthresh = 10^(g_infthreshdb/20);

// per-channel state/configuration record (mem_stlist)
st_monmode = 0; // mirrors chX.monmode
st_note1 = 1; // mirrors chX.note/chX.note2/chX.note3
st_note2 = 2;
st_note3 = 3;

st_state = 4; // 0=off, 1=play, 2=recording
st_buf   = 5; // pointer to audio buffer
st_dirty = 6;  // set if buffer is dirty, and also may indicate how much of it 
               // is using max(mem_stlist[st_dirty],chX.dirty_top+1)
st_lastd = 7; // UI flags for mode + monitor + dirty
st_num   = 8;


function alloc(sz) ( (this.top+=sz)-sz; );

function updatefromrec() instance(rec)
(
  this.note  = rec[st_note1];
  this.note2 = rec[st_note2];
  this.note3 = rec[st_note3];
  this.monmode = rec[st_monmode];
);

function init(x, n1,n2,n3) 
  instance(idx rec buf monvol fpos fpos2 sk_fpos sk_fpos2 dirty_top) 
(
  idx = x;  
  monvol = fpos = fpos2 = sk_fpos = sk_fpos2 = 0;
  dirty_top = -1;
  buf = alloc(g_maxlen);
  
  rec = mem_stlist + x*st_num;
  rec[st_note1] = n1;
  rec[st_note2] = n2;
  rec[st_note3] = n3;
  rec[st_state]=0;
  rec[st_lastd]=-1;
  rec[st_dirty]=0;
  rec[st_monmode] = 1;
  rec[st_buf] = buf;
  
  this.updatefromrec();
);

function process(s) instance(buf, fpos, fpos2, monvol, monmode) local(r) (
  g_recstart_gate==0 ? (
    fpos = fpos*g_fadespeed + this.sk_fpos;
    fpos2 = fpos2*g_fadespeed + this.sk_fpos2;
  ) : (
    fpos = fpos2 = 0;
  );
  
  monmode == 0 ? (
    // no monitoring
    fpos > 0.0001 ? (
      this.dirty_top = max(this.dirty_top,g_pos);
      r=buf[g_pos]*fpos2;
      buf[g_pos] += s*fpos;
      r;
    ) : fpos2 > 0.0001 ? (
      buf[g_pos]*fpos2;
    ) : 0;
    
  ) : ( 
    monvol = monvol*g_fadespeed + (monmode>=2 || g_chan_selected == this.idx)*g_fadespeed2;
  
    fpos > 0.0001 ? (
      this.dirty_top = max(this.dirty_top,g_pos);
      (buf[g_pos] += s*fpos) * fpos2 + s * max(0, monvol - fpos*fpos2);
    ) : fpos2 > 0.0001 ? (
      buf[g_pos]*fpos2 + s*monvol;
    ) : (
      s*monvol;
    );
  );
);

function setstate(st) instance(sk_fpos, sk_fpos2, rec) local(dt)
(
  rec[st_state] ? (
    st==0 ? ( 
      g_active_cnt -= 1; 
    ) : (
      g_firstrec = 0;   
      g_recstart_gate = 0;
    );
  ) : (
    st>0 ? ( 
      st == 2 && (dt = max(rec[st_dirty], this.dirty_top+1)) > 0 ? (
        memset(this.buf,0,dt);
        this.dirty_top=-1;
        rec[st_dirty]=0;
      );
      
      (g_active_cnt += 1) == 1 ? (
        st == 2 ? ( 
          g_recstart_gate = mem_gen_cfg[4] > g_infthreshdb ? ( 10^(mem_gen_cfg[4]/20) );
          g_pos = 0;
          g_length = 0; 
          g_firstrec = 1; 
        );        
      );
    );
  );
  rec[st_state] = st;
  rec[st_dirty] = max(max(rec[st_dirty],this.dirty_top+1),st==2);
  
  sk_fpos = st == 2 ? g_fadespeed2 : 0;
  sk_fpos2 = st > 0 ? g_fadespeed2 : 0;
);

function onmsg(m1,m2,m3) instance(rec,note,note2,note3) (
   m2 == note ? (
     this.setstate((rec[st_state] == 2 && g_firstrec==0) ? 1 : 2);
     g_chan_selected = this.idx;
   ) : m2 == note2 ? (
     this.setstate(rec[st_state] == 2 || (rec[st_state]==0 && g_length) ? 1 : 0);
     g_chan_selected = this.idx;
   ) : m2 == note3 ? (
     g_chan_selected = (g_chan_selected == this.idx) ? -1 : this.idx;
   );
);

function repeatbuf(buf,osz, nsz) local(p,s)
(
  p=buf+osz;
  while (p < buf+nsz) 
  (
    s = min(buf+nsz-p,osz);
    memcpy(p,buf,s);
    p+=s;
  ); 
);

function xfadebuf(buf, osz, nsz) local(fsz,s,ds)
(
  s=0;
  fsz = min(0.001*mem_gen_cfg[5]*srate,osz-nsz)|0;
  ds=1/fsz;
  // fade buf[0..fsz] with buf[nsz..nsz+fsz] 
  loop(fsz,
    buf[0] = buf[0] * s + buf[nsz]*(1-s);
    s+=ds;
    buf+=1;
  );
 
);

function adjustsizes(scale, repup) local(nlen,olen, lp)
(
  olen = g_length;
  nlen = (olen*scale)|0;
  nlen >= 1 && nlen < g_maxlen ? (
    lp=mem_stlist;
    loop(g_nchan,
      lp[st_dirty] ? (
        nlen > olen ? (
          repup ? repeatbuf(lp[st_buf],olen,nlen);
          nlen > lp[st_dirty] ? lp[st_dirty] = nlen;
        ) : (
          xfadebuf(lp[st_buf],olen,nlen);
        );
      );
      lp += st_num;
    );
    g_length = nlen;
    g_pos %= nlen;
  );
);

function updatechfromrec()
(
  ch1.updatefromrec();
  ch2.updatefromrec();
  ch3.updatefromrec();
  ch4.updatefromrec();
  ch5.updatefromrec();
  ch6.updatefromrec();
  ch7.updatefromrec();
  ch8.updatefromrec();
);

function reset() local(i,lp)
( 
  g_chan_selected=-1;
  ch1.setstate(0); ch1.dirty_top=-1; // setstate() will latch dirty_top to st_dirty
  ch2.setstate(0); ch2.dirty_top=-1;
  ch3.setstate(0); ch3.dirty_top=-1;
  ch4.setstate(0); ch4.dirty_top=-1;
  ch5.setstate(0); ch5.dirty_top=-1;
  ch6.setstate(0); ch6.dirty_top=-1;
  ch7.setstate(0); ch7.dirty_top=-1;
  ch8.setstate(0); ch8.dirty_top=-1;
  i=0;
  lp = mem_stlist;
  loop(g_nchan,
    lp[st_dirty] > 0 ? (
      memset(lp[st_buf], 0, lp[st_dirty]);
      lp[st_dirty] = 0;
    );
    i+=1;
    lp += st_num;
  );
  g_length=g_pos=0;
);


function estbpm(len) local(bpm)
(
  bpm = 120.0 * srate / len;
  while (bpm < 60) ( bpm*=2; );
  while (bpm > 240) ( bpm/=2; );
  bpm;
);

function gen_action(i) local(rec, flag)
(
  i == 0 ? reset() : 
  i == 1 ? adjustsizes(0.5,1) : 
  i == 2 ? adjustsizes(2,1) : 
  i == 3 ? adjustsizes(2,0) : 
  i == 7 ? (
    // export!
    rec = mem_stlist;
    flag=3<<16;
    g_length > 0 ? loop(g_nchan,
      rec[st_state] ? (
        export_buffer_to_project(rec[st_buf],g_length,1,srate,(rec-mem_stlist)/st_num, flag, flag?estbpm(g_length));
        flag=0;
      );
      rec+=st_num;
    );
  );
);


// one-time initialization
ext_noinit == 0 ? (
  ext_noinit=1;
  
  alloc.top=0;
  
  mem_gen_sz=8;
  mem_gen_cfg = alloc(mem_gen_sz);
  memset(mem_gen_cfg,128,mem_gen_sz);
  mem_gen_cfg[4]=g_infthreshdb; // gate threshold
  mem_gen_cfg[5]=5; // msec fade when using halve
  mem_gen_cfg[6]=0;
  
  mem_gen_names = alloc(mem_gen_sz);
  mem_gen_names[0] = "kill";
  mem_gen_names[1] = "halve";
  mem_gen_names[2] = "double";
  mem_gen_names[3] = "double\nno rep";
  mem_gen_names[4] = "init rec\nstart gate";
  mem_gen_names[5] = "halve\nfadesz";  
  mem_gen_names[6] = "length\ntweak";  
  mem_gen_names[7] = "add to\nproject";
  
  mem_stlist = alloc(g_nchan * st_num);

  g_inactive_blockcnt=0;  
  g_active_cnt = 0; 
  g_length = 0;
  g_pos=0;
  g_firstrec=0;
  g_recstart_gate=0;
  g_chan_selected = -1; // currently selected channel
  g_lastmsg = -1;
  
  ch1.init(0, 36,37, 128);
  ch2.init(1, 38,39, 128);
  ch3.init(2, 41,42, 128);
  ch4.init(3, 43,44, 128);
  ch5.init(4, 45,46, 128);
  ch6.init(5, 48,49, 128);
  ch7.init(6, 50,51, 128);
  ch8.init(7, 53,54, 128);
);




@serialize
function doconf() local(i,s) (
  i=mem_stlist;
  loop(g_nchan,
    file_var(0,i[st_monmode]);
    i+=st_num;
  );
  
  s=mem_gen_sz; // safe to increase mem_gen_sz without breaking compat
  file_var(0,s);

  i=0;
  loop(s,
    file_var(0,i < mem_gen_sz ? mem_gen_cfg[i] : 0);
    i+=1;
  );
  
  i = mem_stlist;
  loop(g_nchan,
    file_var(0,i[st_note1]);
    file_var(0,i[st_note2]);
    file_var(0,i[st_note3]);
    i+=st_num;
  );
  
  file_avail(0)>=0 ? ( // is reading config
    updatechfromrec();
  );
);
doconf();

@block

g_active_cnt==0? (
  g_inactive_blockcnt < 2 ? ( 
    g_inactive_blockcnt+=1; 
  ) : (
    g_pos = 0
  );
) : g_inactive_blockcnt=0;

sidx=0;
nextmsg_offs=-1;
midirecv(nextmsg_offs,nextmsg_1,nextmsg_2,nextmsg_3) ? midisend(nextmsg_offs,nextmsg_1,nextmsg_2,nextmsg_3);

@sample
while (sidx == nextmsg_offs)
(
  nextmsg_1 == 0x90 && nextmsg_3 != 0  ? (
    ch1.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    ch2.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    ch3.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    ch4.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    ch5.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    ch6.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    ch7.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    ch8.onmsg(nextmsg_1,nextmsg_2,nextmsg_3);
    
    nextmsg_2 == mem_gen_cfg[0] ? gen_action(0) :
      nextmsg_2 == mem_gen_cfg[1] ? gen_action(1) :
      nextmsg_2 == mem_gen_cfg[2] ? gen_action(2) :
      nextmsg_2 == mem_gen_cfg[3] ? gen_action(3);
      
    g_lastmsg = nextmsg_2;
  );
  nextmsg_offs=-1;
  midirecv(nextmsg_offs,nextmsg_1,nextmsg_2,nextmsg_3) ? midisend(nextmsg_offs,nextmsg_1,nextmsg_2,nextmsg_3);  
);

sidx+=1;
g_chan_selected >= 0 ? (
  g_chan_peak = abs(spl(g_chan_selected));
  g_peakvol = max(g_chan_peak,g_peakvol);
  
  g_recstart_gate && g_firstrec ? (
    g_chan_peak >= g_recstart_gate ? g_recstart_gate=0;
  );
);

spl0=ch1.process(spl0);
spl1=ch2.process(spl1);
spl2=ch3.process(spl2);
spl3=ch4.process(spl3);
spl4=ch5.process(spl4);
spl5=ch6.process(spl5);
spl6=ch7.process(spl6);
spl7=ch8.process(spl7);

g_recstart_gate==0 ? ( 
  (g_pos += 1) >= g_length ? (
    g_firstrec ? (
       g_pos >= g_maxlen ? (
         g_firstrec=0;
         g_pos=0;
       ) : (
         g_length = g_pos+1;
       );
    ) : (
      g_pos=0;
    );
  );
);

g_chan_selected >= 0 ? (
  spl8= spl(g_chan_selected);
) : (
  spl8=0;
);
@gfx 420 180

gfx_clear=-1;

function draw_button(xpos,ypos, w, h, bordersz)
(
  gfx_rect(xpos,ypos,w,h);
  bordersz > 0 ? (
    gfx_set(1,1,1);
    gfx_rect(xpos,ypos,bordersz,h);
    gfx_rect(xpos+bordersz,ypos,w-bordersz*2,bordersz);
    gfx_rect(xpos+w-bordersz,ypos,bordersz,h);
    gfx_rect(xpos+bordersz,ypos+h-bordersz,w-bordersz*2,bordersz);
  );
);

function mouse_in(xpos,ypos,w,h) (
  mouse_x>=xpos && mouse_x <= xpos+w && 
    mouse_y>=ypos && mouse_y <= ypos+h;
);

function draw_speaker(xpos, ypos, w)
(
  xpos -= w*.5;
  gfx_line(xpos,ypos-w*.35,xpos+w*.4,ypos-w*.35);
  gfx_line(xpos,ypos-w*.35,xpos,ypos+w*.35);
  gfx_line(xpos,ypos+w*.35,xpos+w*.4,ypos+w*.35);
  gfx_line(xpos+w*.4,ypos-w*.35,xpos+w*.4,ypos+w*.35);
  
  gfx_line(xpos+w*.4,ypos-w*.35,xpos+w*.8,ypos-w*.7);
  gfx_line(xpos+w*.4,ypos+w*.35,xpos+w*.8,ypos+w*.7);

  gfx_line(xpos+w*.8,ypos-w*.7,xpos+w*.8,ypos+w*.7);
  
);

function draw_value_tweaker(xpos,ypos,midimem,draw, tweakmode, forcemousein) local(cap capy t w)
(          
  w = tweakmode > 0 ? 56 : 24;
  cap == midimem ? (
    (mouse_cap&2) ? (
      t = ((mouse_y-capy)*(tweakmode==3 ? 1 : .25))|0;
      t ? (
        tweakmode==1 ? (
          midimem[0] = min(max(midimem[0]-t,g_infthreshdb),-1);
        ) : tweakmode == 2 ? (
          midimem[0] = min(max(midimem[0]-t,0),500);
        ) : tweakmode == 3 ? (
          midimem == mem_gen_cfg+6 && g_length > 0 && !g_firstrec ? (
            midimem[0] -= t;
            t = (t*0.001*srate)|0;
            t ? (
              g_length = max(g_length-t,1);
              g_pos %= g_length;
            );                   
          );
        ) : (
          midimem[0] = min(max(midimem[0]-t,0),128);
        );
        updatechfromrec();
        capy=mouse_y;
        draw=1;
      );
    ) : (
      cap = -1;
    );
  );
  cap == -1 && (mouse_cap & 2) && (forcemousein||mouse_in(xpos,ypos,w,24)) ? (
    cap = midimem;
    tweakmode == 3 ? midimem[0]=0;
    capy = mouse_y;
  );
  draw ? (
    t=midimem[0];
    gfx_set(.35);
    gfx_rect(xpos,ypos,w,24);
    gfx_y=ypos + 8;;
    gfx_set(0.1);
    tweakmode == 1 ? (
      gfx_x=xpos+4;
      t <= g_infthreshdb ? gfx_drawstr("-inf") : gfx_printf("%.0fdB",t);
    ) : tweakmode == 2 ? (
      gfx_x=xpos+4;
      gfx_printf("%.0f ms",t);    
    ) : tweakmode == 3 ? (
      gfx_x=xpos+4;
      gfx_printf("%+.0f ms",t);    
    ) : (
      gfx_x=xpos + (t>=100?0:t>=10?5:9);
      gfx_printf(t > 127 ? "OFF" : "%d",t);
    );
  );
);

function draw(xpos, ypos) local(i w h gap rec mode force_redraw rowsize mx my mw t)
(
  force_redraw = gfx_w != last_w || gfx_h != last_h;
  
  gap = 4;
  rowsize=4;
  w=0|((gfx_w- gap*(rowsize-1))/rowsize);
  
  h=w;
  i=0;
  rec = mem_stlist;
  loop(g_nchan,
    i>0 && (i%rowsize) == 0 ? (
      xpos=0;
      ypos += h + gap;
    );
    
    (mouse_cap&1) && mouse_in(xpos,ypos,w,h) ? (
       g_chan_selected=i;
    );
    mode = rec[st_state];
    gfx_set(mode==2 ? 1 : 0.25,mode==1?1:0.25, 0.25);
    g_chan_selected == i ? mode|=8;
    rec[st_dirty] ? mode|=16;
    mode |= rec[st_monmode] << 8;
    
    mw = (w*.25)|0;
    mx = xpos + w - mw - gap;
    my = ypos+gap;
  
    force_redraw || rec[st_lastd] != mode ? (
      rec[st_lastd] = mode;
      draw_button(xpos,ypos,w,h,g_chan_selected == i ? gap : 0);
    
      gfx_set(1,1,1);
      gfx_x = xpos + 8;
      gfx_y = ypos + 8;
      gfx_printf("%d",i+1);    
      
      rec[st_monmode]==0 ? (
        gfx_set(0.2)
      ) : rec[st_monmode]==1 ? (
        (mode&8) ? gfx_set(0.3,0.3,1.0) : gfx_set(0.3,0.3,0.7) 
      ) : (
        gfx_set(0.9,0.8,0);
      );
      
      gfx_rect(mx,my,mw,mw);
      
      rec[st_monmode] == 0 ? (
        gfx_set(0);
      ) : (
        rec[st_monmode]==2 || (mode&8) ? (       
          gfx_set(1,1,1, 1);
        ) : (
          gfx_set(1,1,1, .25);
        );
      );
      draw_speaker(mx+mw/2,my+mw/2,mw/2);    
        
      rec[st_monmode] == 0 ? (
        gfx_set(0);
        gfx_line(mx,my,mx+mw,my+mw);
        gfx_line(mx+mw,my,mx,my+mw);
      );
    
      rec[st_dirty] ? (
        gfx_set(0,0.5,0.75);
        gfx_rect(xpos+gap,ypos+h-h/8-gap,w-gap*2,ceil(h/8));
      );
      
      t = mem_stlist + i*st_num;
      draw_value_tweaker(xpos+w-(24+gap)*3,ypos+h-24-gap,t + st_note1,1, 0,0);
      draw_value_tweaker(xpos+w-(24+gap)*2,ypos+h-24-gap,t + st_note2,1, 0,0);
      draw_value_tweaker(xpos+w-(24+gap),ypos+h-24-gap,t + st_note3,1, 0,0);
    ) : (
      t = mem_stlist + i*st_num;
      draw_value_tweaker(xpos+w-(24+gap)*3,ypos+h-24-gap,t + st_note1,0, 0,0);
      draw_value_tweaker(xpos+w-(24+gap)*2,ypos+h-24-gap,t + st_note2,0, 0,0);
      draw_value_tweaker(xpos+w-(24+gap),ypos+h-24-gap,t + st_note3,0, 0,0);
    );
    (mouse_cap&2) && !(last_mouse_cap&2) && mouse_in(mx,my,mw,mw) ? (
      rec[st_monmode] = (rec[st_monmode]+1)%3;
      updatechfromrec();
    );
    
    xpos += w + gap;
    i+=1;
    rec += st_num;
  );
  xpos = 0;
  ypos += h+gap;

  i=0;
  loop(mem_gen_sz,
    i>0 && (i%rowsize) == 0 ? (
      xpos=0;
      ypos += h + gap;
    );
      
    force_redraw ? (
      i == 1 ? gfx_set(0.0, 0.5, 0.6) :
      i == 2 ? gfx_set(0.0, 0.6, 0.5) : 
      i == 3 ? gfx_set(0.0, 0.6, 0.4) : 
      i == 4 ? gfx_set(0.3, 0.3, 0.6) :
      i == 5 ? gfx_set(0.3, 0.5, 0.8) :
      i == 6 ? gfx_set(0.8 ,0.5, 0.3) :
      i == 7 ? gfx_set(0.7, 0.6, 0.7) :
               gfx_set(0.5, 0.0, 0.0);
        
      draw_button(xpos,ypos,w,h,0);
      gfx_set(1);
      gfx_x=xpos+w/2 - 8*strlen(mem_gen_names[i])*(match("+\n+",mem_gen_names[i])?0.25:0.5);
      gfx_y=ypos+h/2 - 4;
      gfx_drawstr(mem_gen_names[i]);
    );
    draw_value_tweaker(xpos+w-(i>=4&&i!=7?56:24)-gap,ypos+h-24-gap,mem_gen_cfg + i,
       force_redraw, i==4?1:i==5?2:i==6?3:0,
       i>=4 && i!=7?mouse_in(xpos,ypos,w,h):0);
    
    !(last_mouse_cap&1) && (mouse_cap&1) && mouse_in(xpos,ypos,w,h) ? (
      gen_action(i);
    );
      
    xpos += w+gap;
    i+=1;
  );
  
  
);

function draw_position() local(last_pos,last_len)
(
  last_w != gfx_w || last_h != gfx_h || last_pos != g_pos || last_len != g_length ? (
    last_len = g_length;
    last_pos = g_pos;
    gfx_set(0.225,0.125,0.125);
    gfx_rect(0,0,gfx_w,20);
    gfx_set(0.125,0.25,0.25);
    gfx_rect(0,0,g_pos/g_length * gfx_w,20);
    gfx_x=2;
    gfx_y=2;
    gfx_set(1,1,1);
    gfx_printf("%d mS\n%.1f BPM",g_length/srate * 1000,estbpm(last_len));
  );
);

last_w != gfx_w || last_h != gfx_h ? (
 gfx_set(0.125);
 gfx_rect(0,0,gfx_w,gfx_h);
);

draw_position();
draw(0, 30);

gfx_x=0;
gfx_y=gfx_h-8;
gfx_set(0);
gfx_rect(gfx_x,gfx_y,6*8,8);
gfx_set(.3);
g_peakvol < g_infthresh ? (
  gfx_printf("-inf");
) : (
  gfx_printf("%.0fdB",log10(g_peakvol)*20);
  g_peakvol *= 0.93;
);


g_lastmsg>=0 && g_lastmsg_draw!=g_lastmsg ? (
  gfx_x=gfx_w-24;
  gfx_y=gfx_h-8;
  gfx_set(0);
  gfx_rect(gfx_x,gfx_y,24,8);
  gfx_set(.3);
  gfx_x += g_lastmsg<10?16:g_lastmsg<100?8;
  gfx_printf("%d",g_lastmsg);
  g_lastmsg_draw=g_lastmsg;
);

last_w = gfx_w;
last_h = gfx_h;
last_mouse_cap = mouse_cap;
